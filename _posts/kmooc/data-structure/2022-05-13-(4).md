---
layout: post
header-style: text
title: 인공지능을 위한 알고리즘과 자료구조 (4)
subtitle: 함수의 점근적 분석
author: Juri
tag:
    - datastructure
    - algorithms
    - kmooc
---

## 함수의 점근적 분석 (asymptotic analysis)

문제의 크기가 아주 크게 증가했을 때, 우리가 갖고 있는 이 알고리즘은 얼마 만큼의 계산량을 요구하는가를 분석한다. 만약 같은 문제를 푸는 서로 다른 2개의 알고리즘을 갖고 있다고 했을 때, 어떤 알고리즘이 더 좋은 지에 대해 과학적이고 수치적으로 표현할 수 있다.

두 알고리즘을 비교하기 위해 프로그램을 짜서 테스트를 해보는 것이 가장 간단한 방법이다. 실제로 알고리즘 소요시간과 소비 메모리를 측정할 수 있지만 프로그래밍 비용이 비싸고 human error가 발생할 수 있다. 따라서 알고리즘을 수학적으로 분석해 비교해보자는 것이다.

-   하나 이상의 variable과 관련하여 알고리즘을 분석한다.
-   어떤 배열에 몇개의 N개의 요소가 있다. -> N이 variable이 된다.

### Linear and Binary Search

**Linear Search**

배열에서 특정한 값을 찾을 대 앞에서부터 순차적으로 찾는 방법

**Binary Search**
중간값과 찾고자 하는 값을 비교해 대소관계에 따라 반은 검색 대상에서 제외, 나머지 반에서 검색을 반복 수행하는 방법. 단, 배열이 정렬되어 있을때만 가능하다.

![](/img/in-post/search.jpg)

Linear search는 선형적으로 증가하는 반면 Binary search는 x의 값이 증가해도 y의 증가폭은 낮다는 것을 알 수 있다. 즉, Linear search보다 Binary search가 효율적인 알고리즘이라고 할 수 있다.

알고리즘이 주어졌을 때 알고리즘의 성능을 테스트하는 지표로 무엇을 삼을 것인지 선택해야 한다. (위의 알고리즘에서는 '비교횟수'가 알고리즘의 계산량을 표현하는 variable이 됐다.) 뿐만 아니라 알고리즘과 자료구조의 관계를 고려해 점근적 분석을 수행해야 하며 기계에서 구동시키는 것과 독립적으로 수학적으로만 이뤄져야 한다.

### Weak ordering

![](/img/in-post/search2.png)

첫번째 알고리즘이 f(n)의 복잡도를 갖고 f(n)만큼의 시행횟수를 요구한다. 마찬가지로, 두번째 알고리즘이 g(n)의 복잡도를 갖고 g(n)만큼의 시행횟수를 요구한다. a_k와 b_k가 0이 아니고 f(n)과 g(n)이 모두 n^k 승을 최고차항일 때,

![](/img/in-post/search3.png)

어떤 **M**이라는 숫자를 설정하면 a_k와 b_k가 어떤 값이 되도 M x g(n)을 f(n)보다 크게 만들 수 있다.

즉, f(n)이 더 커서 g(n)이 더 효율적인 알고리즘이라고 해도 M배 빠른 컴퓨터로 f(n)에 해당하는 알고리즘을 구동시키면 속도차이가 뒤집힐 수 있다. 최고차항 앞의 계수 부분은 더 빠른 컴퓨터로 커버할 수 있지만 최고차항의 승수가 다르면 따라잡을 수 없는 속도 차이가 생긴다.

이를 기반으로 **Weak ordering**이라는 개념을 도입한다.

![](/img/in-post/search4.png)

두 함수가 주어졌을 때, 이 둘의 비율인 g(n)분의 f(n)이 n이 무한대로 증가할 때 어떤 constant에 수렴하면 두 알고리즘은 비슷한 복잡도를 가지고 있다고 하고 `f~g`로 표현한다.

이 비율의 값이 0에 수렴하면 g(n)이 더 큰 것으로 `f<g`로 표현한다.

n^2과 2n^2은 같은 동일선상에 놓고 대소관계를 구분하지 않기 때문에 weak ordering이라는 표현을 사용하는 것이다.

### 정리

f(n)과 g(n)이 동일 선상에 있다고 할 때, 더 빠른 컴퓨터를 사용하면 이 둘의 격차를 뒤집을 수 있으며, 반대로 g(n)이 f(n)보다 더 커서 빠른 컴퓨터를 사용해도 이 둘의 대소관계를 뒤집을 수 없을 때 f(n)의 알고리즘이 g(n)의 알고리즘보다 효율적이라고 얘기할 수 있다.
